//! This is the harness code for differential fuzzing with `afl`. The harness
//! is generated by Veri-easy based on the verified and original implementations
//! of the allocator.
//!
//! Since `serde` does not support deserializing big arrays, based on the 
//! generated harness, we manually implement the deserialization from bytes
//! for those structs that contain big arrays.
//!
//! This file will be copied to the `df_harness` crate before fuzzing. See
//! `pre_fuzz_cmd` in `workflow.toml`. 

#![allow(unused)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
mod mod1;
mod mod2;
use mod1::BitAlloc as Mod1BitAlloc;
use mod1::BitField as Mod1BitField;
use mod2::BitAlloc as Mod2BitAlloc;
use mod2::BitAllocView as Mod2BitAllocView;
macro_rules ! outputln { ($ ($ arg : tt) *) => { writeln ! (get_harness_output () , $ ($ arg) *) . unwrap () ; } ; }
use std::io::Write;
static HARNESS_OUTPUT: std::sync::OnceLock<std::fs::File> = std::sync::OnceLock::new();
fn init_harness_output() {
    HARNESS_OUTPUT
        .set(std::fs::File::create("harness_output.log").unwrap())
        .unwrap();
}
fn get_harness_output() -> &'static std::fs::File {
    HARNESS_OUTPUT.get().expect("not initialized")
}
fn main() {
    init_harness_output();
    afl::fuzz_nohook!(|data: &[u8]| {
        if !run_harness(data) {
            panic!("Harness reported failure for input: {:?}", data);
        }
    });
}
#[derive(Debug, serde :: Deserialize)]
pub struct ArgsBitAlloc256___verieasy_new {
    pub bitmap: [u16; 16],
}
#[derive(Debug)]
pub struct ArgsBitAlloc4K___verieasy_new {
    pub bitmap: [u16; 256],
}
impl ArgsBitAlloc4K___verieasy_new {
    fn take_from_bytes(input: &[u8]) -> Result<(Self, &[u8]), ()> {
        if input.len() < 512 {
            return Err(());
        }
        let mut bitmap = [0u16; 256];
        for i in 0..256 {
            bitmap[i] = u16::from_le_bytes([input[i * 2], input[i * 2 + 1]]);
        }
        Ok((ArgsBitAlloc4K___verieasy_new { bitmap }, &input[512..]))
    }
}

#[derive(Debug)]
pub struct ArgsBitAlloc64K___verieasy_new {
    pub bitmap: [u16; 4096],
}

impl ArgsBitAlloc64K___verieasy_new {
    fn take_from_bytes(input: &[u8]) -> Result<(Self, &[u8]), ()> {
        if input.len() < 8192 {
            return Err(());
        }
        let mut bitmap = [0u16; 4096];
        for i in 0..4096 {
            bitmap[i] = u16::from_le_bytes([input[i * 2], input[i * 2 + 1]]);
        }
        Ok((ArgsBitAlloc64K___verieasy_new { bitmap }, &input[8192..]))
    }
}

#[derive(Debug)]
pub struct ArgsBitAlloc1M___verieasy_new {
    pub bitmap: [u16; 65536],
}
impl ArgsBitAlloc1M___verieasy_new {
    fn take_from_bytes(input: &[u8]) -> Result<(Self, &[u8]), ()> {
        if input.len() < 131072 {
            return Err(());
        }
        let mut bitmap = [0u16; 65536];
        for i in 0..65536 {
            bitmap[i] = u16::from_le_bytes([input[i * 2], input[i * 2 + 1]]);
        }
        Ok((ArgsBitAlloc1M___verieasy_new { bitmap }, &input[131072..]))
    }
}

#[derive(Debug, serde :: Deserialize)]
pub struct ArgsBitAlloc16___verieasy_new {
    pub bits: u16,
}
#[derive(Debug, serde :: Deserialize)]
pub struct ArgsBitAlloc256___alloc {}
#[derive(Debug, serde :: Deserialize)]
pub struct ArgsBitAlloc4K___alloc {}
#[derive(Debug, serde :: Deserialize)]
pub struct ArgsBitAlloc64K___alloc {}
#[derive(Debug, serde :: Deserialize)]
pub struct ArgsBitAlloc1M___alloc {}
#[derive(Debug, serde :: Deserialize)]
pub struct ArgsBitAlloc256___alloc_contiguous {
    pub size: usize,
    pub align_log2: usize,
}
#[derive(Debug, serde :: Deserialize)]
pub struct ArgsBitAlloc4K___alloc_contiguous {
    pub size: usize,
    pub align_log2: usize,
}
#[derive(Debug, serde :: Deserialize)]
pub struct ArgsBitAlloc64K___alloc_contiguous {
    pub size: usize,
    pub align_log2: usize,
}
#[derive(Debug, serde :: Deserialize)]
pub struct ArgsBitAlloc1M___alloc_contiguous {
    pub size: usize,
    pub align_log2: usize,
}
#[derive(Debug, serde :: Deserialize)]
pub struct ArgsBitAlloc256___dealloc {
    pub key: usize,
}
#[derive(Debug, serde :: Deserialize)]
pub struct ArgsBitAlloc4K___dealloc {
    pub key: usize,
}
#[derive(Debug, serde :: Deserialize)]
pub struct ArgsBitAlloc64K___dealloc {
    pub key: usize,
}
#[derive(Debug, serde :: Deserialize)]
pub struct ArgsBitAlloc1M___dealloc {
    pub key: usize,
}
#[derive(Debug, serde :: Deserialize)]
pub struct ArgsBitAlloc256___insert {
    pub range: std::ops::Range<usize>,
}
#[derive(Debug, serde :: Deserialize)]
pub struct ArgsBitAlloc4K___insert {
    pub range: std::ops::Range<usize>,
}
#[derive(Debug, serde :: Deserialize)]
pub struct ArgsBitAlloc64K___insert {
    pub range: std::ops::Range<usize>,
}
#[derive(Debug, serde :: Deserialize)]
pub struct ArgsBitAlloc1M___insert {
    pub range: std::ops::Range<usize>,
}
#[derive(Debug, serde :: Deserialize)]
pub struct ArgsBitAlloc256___remove {
    pub range: std::ops::Range<usize>,
}
#[derive(Debug, serde :: Deserialize)]
pub struct ArgsBitAlloc4K___remove {
    pub range: std::ops::Range<usize>,
}
#[derive(Debug, serde :: Deserialize)]
pub struct ArgsBitAlloc64K___remove {
    pub range: std::ops::Range<usize>,
}
#[derive(Debug, serde :: Deserialize)]
pub struct ArgsBitAlloc1M___remove {
    pub range: std::ops::Range<usize>,
}
#[derive(Debug, serde :: Deserialize)]
pub struct ArgsBitAlloc256___any {}
#[derive(Debug, serde :: Deserialize)]
pub struct ArgsBitAlloc4K___any {}
#[derive(Debug, serde :: Deserialize)]
pub struct ArgsBitAlloc64K___any {}
#[derive(Debug, serde :: Deserialize)]
pub struct ArgsBitAlloc1M___any {}
#[derive(Debug, serde :: Deserialize)]
pub struct ArgsBitAlloc256___test {
    pub key: usize,
}
#[derive(Debug, serde :: Deserialize)]
pub struct ArgsBitAlloc4K___test {
    pub key: usize,
}
#[derive(Debug, serde :: Deserialize)]
pub struct ArgsBitAlloc64K___test {
    pub key: usize,
}
#[derive(Debug, serde :: Deserialize)]
pub struct ArgsBitAlloc1M___test {
    pub key: usize,
}
#[derive(Debug, serde :: Deserialize)]
pub struct ArgsBitAlloc256___next {
    pub key: usize,
}
#[derive(Debug, serde :: Deserialize)]
pub struct ArgsBitAlloc4K___next {
    pub key: usize,
}
#[derive(Debug, serde :: Deserialize)]
pub struct ArgsBitAlloc64K___next {
    pub key: usize,
}
#[derive(Debug, serde :: Deserialize)]
pub struct ArgsBitAlloc1M___next {
    pub key: usize,
}
#[derive(Debug, serde :: Deserialize)]
pub struct ArgsBitAlloc16___alloc {}
#[derive(Debug, serde :: Deserialize)]
pub struct ArgsBitAlloc16___alloc_contiguous {
    pub size: usize,
    pub align_log2: usize,
}
#[derive(Debug, serde :: Deserialize)]
pub struct ArgsBitAlloc16___dealloc {
    pub key: usize,
}
#[derive(Debug, serde :: Deserialize)]
pub struct ArgsBitAlloc16___insert {
    pub range: std::ops::Range<usize>,
}
#[derive(Debug, serde :: Deserialize)]
pub struct ArgsBitAlloc16___remove {
    pub range: std::ops::Range<usize>,
}
#[derive(Debug, serde :: Deserialize)]
pub struct ArgsBitAlloc16___any {}
#[derive(Debug, serde :: Deserialize)]
pub struct ArgsBitAlloc16___test {
    pub key: usize,
}
#[derive(Debug, serde :: Deserialize)]
pub struct ArgsBitAlloc16___next {
    pub key: usize,
}
#[inline(always)]
fn check_BitAlloc256___alloc(input: &[u8]) -> bool {
    let (constr_arg_struct, remain) =
        match postcard::take_from_bytes::<ArgsBitAlloc256___verieasy_new>(&input[..]) {
            Ok((args, remain)) => (args, remain),
            Err(_) => return true,
        };
    let method_arg_struct = match postcard::from_bytes::<ArgsBitAlloc256___alloc>(&remain[..]) {
        Ok(args) => args,
        Err(_) => return true,
    };
    let mut s1 = mod1::BitAlloc256::verieasy_new(constr_arg_struct.bitmap.clone());
    let mut s2 = mod2::BitAlloc256::verieasy_new(constr_arg_struct.bitmap.clone());
    if !s2.verieasy_pre_alloc() {
        return true;
    }
    let r1 = mod1::BitAlloc256::alloc(&mut s1);
    let r2 = mod2::BitAlloc256::alloc(&mut s2);
    if r1 != r2 {
        outputln!("MISMATCH: {}", "BitAlloc256::alloc");
        outputln!("contructor: {:?}", constr_arg_struct);
        outputln!("method: {:?}", method_arg_struct);
        return false;
    }
    if s1.verieasy_get() != s2.verieasy_get() {
        outputln!("MISMATCH: {}", "BitAlloc256::alloc");
        outputln!("contructor: {:?}", constr_arg_struct);
        outputln!("method: {:?}", method_arg_struct);
        return false;
    }
    true
}
#[inline(always)]
fn check_BitAlloc4K___alloc(input: &[u8]) -> bool {
    let (constr_arg_struct, remain) =
        match ArgsBitAlloc4K___verieasy_new::take_from_bytes(&input[..]) {
            Ok((args, remain)) => (args, remain),
            Err(_) => return true,
        };
    let method_arg_struct = match postcard::from_bytes::<ArgsBitAlloc4K___alloc>(&remain[..]) {
        Ok(args) => args,
        Err(_) => return true,
    };
    let mut s1 = mod1::BitAlloc4K::verieasy_new(constr_arg_struct.bitmap.clone());
    let mut s2 = mod2::BitAlloc4K::verieasy_new(constr_arg_struct.bitmap.clone());
    if !s2.verieasy_pre_alloc() {
        return true;
    }
    let r1 = mod1::BitAlloc4K::alloc(&mut s1);
    let r2 = mod2::BitAlloc4K::alloc(&mut s2);
    if r1 != r2 {
        outputln!("MISMATCH: {}", "BitAlloc4K::alloc");
        outputln!("contructor: {:?}", constr_arg_struct);
        outputln!("method: {:?}", method_arg_struct);
        return false;
    }
    if s1.verieasy_get() != s2.verieasy_get() {
        outputln!("MISMATCH: {}", "BitAlloc4K::alloc");
        outputln!("contructor: {:?}", constr_arg_struct);
        outputln!("method: {:?}", method_arg_struct);
        return false;
    }
    true
}
#[inline(always)]
fn check_BitAlloc64K___alloc(input: &[u8]) -> bool {
    let (constr_arg_struct, remain) =
        match ArgsBitAlloc64K___verieasy_new::take_from_bytes(&input[..]) {
            Ok((args, remain)) => (args, remain),
            Err(_) => return true,
        };
    let method_arg_struct = match postcard::from_bytes::<ArgsBitAlloc64K___alloc>(&remain[..]) {
        Ok(args) => args,
        Err(_) => return true,
    };
    let mut s1 = mod1::BitAlloc64K::verieasy_new(constr_arg_struct.bitmap.clone());
    let mut s2 = mod2::BitAlloc64K::verieasy_new(constr_arg_struct.bitmap.clone());
    if !s2.verieasy_pre_alloc() {
        return true;
    }
    let r1 = mod1::BitAlloc64K::alloc(&mut s1);
    let r2 = mod2::BitAlloc64K::alloc(&mut s2);
    if r1 != r2 {
        outputln!("MISMATCH: {}", "BitAlloc64K::alloc");
        outputln!("contructor: {:?}", constr_arg_struct);
        outputln!("method: {:?}", method_arg_struct);
        return false;
    }
    if s1.verieasy_get() != s2.verieasy_get() {
        outputln!("MISMATCH: {}", "BitAlloc64K::alloc");
        outputln!("contructor: {:?}", constr_arg_struct);
        outputln!("method: {:?}", method_arg_struct);
        return false;
    }
    true
}
#[inline(always)]
fn check_BitAlloc1M___alloc(input: &[u8]) -> bool {
    let (constr_arg_struct, remain) =
        match ArgsBitAlloc1M___verieasy_new::take_from_bytes(&input[..]) {
            Ok((args, remain)) => (args, remain),
            Err(_) => return true,
        };
    let method_arg_struct = match postcard::from_bytes::<ArgsBitAlloc1M___alloc>(&remain[..]) {
        Ok(args) => args,
        Err(_) => return true,
    };
    let mut s1 = mod1::BitAlloc1M::verieasy_new(constr_arg_struct.bitmap.clone());
    let mut s2 = mod2::BitAlloc1M::verieasy_new(constr_arg_struct.bitmap.clone());
    if !s2.verieasy_pre_alloc() {
        return true;
    }
    let r1 = mod1::BitAlloc1M::alloc(&mut s1);
    let r2 = mod2::BitAlloc1M::alloc(&mut s2);
    if r1 != r2 {
        outputln!("MISMATCH: {}", "BitAlloc1M::alloc");
        outputln!("contructor: {:?}", constr_arg_struct);
        outputln!("method: {:?}", method_arg_struct);
        return false;
    }
    if s1.verieasy_get() != s2.verieasy_get() {
        outputln!("MISMATCH: {}", "BitAlloc1M::alloc");
        outputln!("contructor: {:?}", constr_arg_struct);
        outputln!("method: {:?}", method_arg_struct);
        return false;
    }
    true
}
#[inline(always)]
fn check_BitAlloc256___alloc_contiguous(input: &[u8]) -> bool {
    let (constr_arg_struct, remain) =
        match postcard::take_from_bytes::<ArgsBitAlloc256___verieasy_new>(&input[..]) {
            Ok((args, remain)) => (args, remain),
            Err(_) => return true,
        };
    let method_arg_struct =
        match postcard::from_bytes::<ArgsBitAlloc256___alloc_contiguous>(&remain[..]) {
            Ok(args) => args,
            Err(_) => return true,
        };
    let mut s1 = mod1::BitAlloc256::verieasy_new(constr_arg_struct.bitmap.clone());
    let mut s2 = mod2::BitAlloc256::verieasy_new(constr_arg_struct.bitmap.clone());
    if !s2.verieasy_pre_alloc_contiguous(
        method_arg_struct.size.clone(),
        method_arg_struct.align_log2.clone(),
    ) {
        return true;
    }
    let r1 = mod1::BitAlloc256::alloc_contiguous(
        &mut s1,
        method_arg_struct.size.clone(),
        method_arg_struct.align_log2.clone(),
    );
    let r2 = mod2::BitAlloc256::alloc_contiguous(
        &mut s2,
        method_arg_struct.size.clone(),
        method_arg_struct.align_log2.clone(),
    );
    if r1 != r2 {
        outputln!("MISMATCH: {}", "BitAlloc256::alloc_contiguous");
        outputln!("contructor: {:?}", constr_arg_struct);
        outputln!("method: {:?}", method_arg_struct);
        return false;
    }
    if s1.verieasy_get() != s2.verieasy_get() {
        outputln!("MISMATCH: {}", "BitAlloc256::alloc_contiguous");
        outputln!("contructor: {:?}", constr_arg_struct);
        outputln!("method: {:?}", method_arg_struct);
        return false;
    }
    true
}
#[inline(always)]
fn check_BitAlloc4K___alloc_contiguous(input: &[u8]) -> bool {
    let (constr_arg_struct, remain) =
        match ArgsBitAlloc4K___verieasy_new::take_from_bytes(&input[..]) {
            Ok((args, remain)) => (args, remain),
            Err(_) => return true,
        };
    let method_arg_struct =
        match postcard::from_bytes::<ArgsBitAlloc4K___alloc_contiguous>(&remain[..]) {
            Ok(args) => args,
            Err(_) => return true,
        };
    let mut s1 = mod1::BitAlloc4K::verieasy_new(constr_arg_struct.bitmap.clone());
    let mut s2 = mod2::BitAlloc4K::verieasy_new(constr_arg_struct.bitmap.clone());
    if !s2.verieasy_pre_alloc_contiguous(
        method_arg_struct.size.clone(),
        method_arg_struct.align_log2.clone(),
    ) {
        return true;
    }
    let r1 = mod1::BitAlloc4K::alloc_contiguous(
        &mut s1,
        method_arg_struct.size.clone(),
        method_arg_struct.align_log2.clone(),
    );
    let r2 = mod2::BitAlloc4K::alloc_contiguous(
        &mut s2,
        method_arg_struct.size.clone(),
        method_arg_struct.align_log2.clone(),
    );
    if r1 != r2 {
        outputln!("MISMATCH: {}", "BitAlloc4K::alloc_contiguous");
        outputln!("contructor: {:?}", constr_arg_struct);
        outputln!("method: {:?}", method_arg_struct);
        return false;
    }
    if s1.verieasy_get() != s2.verieasy_get() {
        outputln!("MISMATCH: {}", "BitAlloc4K::alloc_contiguous");
        outputln!("contructor: {:?}", constr_arg_struct);
        outputln!("method: {:?}", method_arg_struct);
        return false;
    }
    true
}
#[inline(always)]
fn check_BitAlloc64K___alloc_contiguous(input: &[u8]) -> bool {
    let (constr_arg_struct, remain) =
        match ArgsBitAlloc64K___verieasy_new::take_from_bytes(&input[..]) {
            Ok((args, remain)) => (args, remain),
            Err(_) => return true,
        };
    let method_arg_struct =
        match postcard::from_bytes::<ArgsBitAlloc64K___alloc_contiguous>(&remain[..]) {
            Ok(args) => args,
            Err(_) => return true,
        };
    let mut s1 = mod1::BitAlloc64K::verieasy_new(constr_arg_struct.bitmap.clone());
    let mut s2 = mod2::BitAlloc64K::verieasy_new(constr_arg_struct.bitmap.clone());
    if !s2.verieasy_pre_alloc_contiguous(
        method_arg_struct.size.clone(),
        method_arg_struct.align_log2.clone(),
    ) {
        return true;
    }
    let r1 = mod1::BitAlloc64K::alloc_contiguous(
        &mut s1,
        method_arg_struct.size.clone(),
        method_arg_struct.align_log2.clone(),
    );
    let r2 = mod2::BitAlloc64K::alloc_contiguous(
        &mut s2,
        method_arg_struct.size.clone(),
        method_arg_struct.align_log2.clone(),
    );
    if r1 != r2 {
        outputln!("MISMATCH: {}", "BitAlloc64K::alloc_contiguous");
        outputln!("contructor: {:?}", constr_arg_struct);
        outputln!("method: {:?}", method_arg_struct);
        return false;
    }
    if s1.verieasy_get() != s2.verieasy_get() {
        outputln!("MISMATCH: {}", "BitAlloc64K::alloc_contiguous");
        outputln!("contructor: {:?}", constr_arg_struct);
        outputln!("method: {:?}", method_arg_struct);
        return false;
    }
    true
}
#[inline(always)]
fn check_BitAlloc1M___alloc_contiguous(input: &[u8]) -> bool {
    let (constr_arg_struct, remain) =
        match ArgsBitAlloc1M___verieasy_new::take_from_bytes(&input[..]) {
            Ok((args, remain)) => (args, remain),
            Err(_) => return true,
        };
    let method_arg_struct =
        match postcard::from_bytes::<ArgsBitAlloc1M___alloc_contiguous>(&remain[..]) {
            Ok(args) => args,
            Err(_) => return true,
        };
    let mut s1 = mod1::BitAlloc1M::verieasy_new(constr_arg_struct.bitmap.clone());
    let mut s2 = mod2::BitAlloc1M::verieasy_new(constr_arg_struct.bitmap.clone());
    if !s2.verieasy_pre_alloc_contiguous(
        method_arg_struct.size.clone(),
        method_arg_struct.align_log2.clone(),
    ) {
        return true;
    }
    let r1 = mod1::BitAlloc1M::alloc_contiguous(
        &mut s1,
        method_arg_struct.size.clone(),
        method_arg_struct.align_log2.clone(),
    );
    let r2 = mod2::BitAlloc1M::alloc_contiguous(
        &mut s2,
        method_arg_struct.size.clone(),
        method_arg_struct.align_log2.clone(),
    );
    if r1 != r2 {
        outputln!("MISMATCH: {}", "BitAlloc1M::alloc_contiguous");
        outputln!("contructor: {:?}", constr_arg_struct);
        outputln!("method: {:?}", method_arg_struct);
        return false;
    }
    if s1.verieasy_get() != s2.verieasy_get() {
        outputln!("MISMATCH: {}", "BitAlloc1M::alloc_contiguous");
        outputln!("contructor: {:?}", constr_arg_struct);
        outputln!("method: {:?}", method_arg_struct);
        return false;
    }
    true
}
#[inline(always)]
fn check_BitAlloc256___dealloc(input: &[u8]) -> bool {
    let (constr_arg_struct, remain) =
        match postcard::take_from_bytes::<ArgsBitAlloc256___verieasy_new>(&input[..]) {
            Ok((args, remain)) => (args, remain),
            Err(_) => return true,
        };
    let method_arg_struct = match postcard::from_bytes::<ArgsBitAlloc256___dealloc>(&remain[..]) {
        Ok(args) => args,
        Err(_) => return true,
    };
    let mut s1 = mod1::BitAlloc256::verieasy_new(constr_arg_struct.bitmap.clone());
    let mut s2 = mod2::BitAlloc256::verieasy_new(constr_arg_struct.bitmap.clone());
    if !s2.verieasy_pre_dealloc(method_arg_struct.key.clone()) {
        return true;
    }
    let r1 = mod1::BitAlloc256::dealloc(&mut s1, method_arg_struct.key.clone());
    let r2 = mod2::BitAlloc256::dealloc(&mut s2, method_arg_struct.key.clone());
    if r1 != r2 {
        outputln!("MISMATCH: {}", "BitAlloc256::dealloc");
        outputln!("contructor: {:?}", constr_arg_struct);
        outputln!("method: {:?}", method_arg_struct);
        return false;
    }
    if s1.verieasy_get() != s2.verieasy_get() {
        outputln!("MISMATCH: {}", "BitAlloc256::dealloc");
        outputln!("contructor: {:?}", constr_arg_struct);
        outputln!("method: {:?}", method_arg_struct);
        return false;
    }
    true
}
#[inline(always)]
fn check_BitAlloc4K___dealloc(input: &[u8]) -> bool {
    let (constr_arg_struct, remain) =
        match ArgsBitAlloc4K___verieasy_new::take_from_bytes(&input[..]) {
            Ok((args, remain)) => (args, remain),
            Err(_) => return true,
        };
    let method_arg_struct = match postcard::from_bytes::<ArgsBitAlloc4K___dealloc>(&remain[..]) {
        Ok(args) => args,
        Err(_) => return true,
    };
    let mut s1 = mod1::BitAlloc4K::verieasy_new(constr_arg_struct.bitmap.clone());
    let mut s2 = mod2::BitAlloc4K::verieasy_new(constr_arg_struct.bitmap.clone());
    if !s2.verieasy_pre_dealloc(method_arg_struct.key.clone()) {
        return true;
    }
    let r1 = mod1::BitAlloc4K::dealloc(&mut s1, method_arg_struct.key.clone());
    let r2 = mod2::BitAlloc4K::dealloc(&mut s2, method_arg_struct.key.clone());
    if r1 != r2 {
        outputln!("MISMATCH: {}", "BitAlloc4K::dealloc");
        outputln!("contructor: {:?}", constr_arg_struct);
        outputln!("method: {:?}", method_arg_struct);
        return false;
    }
    if s1.verieasy_get() != s2.verieasy_get() {
        outputln!("MISMATCH: {}", "BitAlloc4K::dealloc");
        outputln!("contructor: {:?}", constr_arg_struct);
        outputln!("method: {:?}", method_arg_struct);
        return false;
    }
    true
}
#[inline(always)]
fn check_BitAlloc64K___dealloc(input: &[u8]) -> bool {
    let (constr_arg_struct, remain) =
        match ArgsBitAlloc64K___verieasy_new::take_from_bytes(&input[..]) {
            Ok((args, remain)) => (args, remain),
            Err(_) => return true,
        };
    let method_arg_struct = match postcard::from_bytes::<ArgsBitAlloc64K___dealloc>(&remain[..]) {
        Ok(args) => args,
        Err(_) => return true,
    };
    let mut s1 = mod1::BitAlloc64K::verieasy_new(constr_arg_struct.bitmap.clone());
    let mut s2 = mod2::BitAlloc64K::verieasy_new(constr_arg_struct.bitmap.clone());
    if !s2.verieasy_pre_dealloc(method_arg_struct.key.clone()) {
        return true;
    }
    let r1 = mod1::BitAlloc64K::dealloc(&mut s1, method_arg_struct.key.clone());
    let r2 = mod2::BitAlloc64K::dealloc(&mut s2, method_arg_struct.key.clone());
    if r1 != r2 {
        outputln!("MISMATCH: {}", "BitAlloc64K::dealloc");
        outputln!("contructor: {:?}", constr_arg_struct);
        outputln!("method: {:?}", method_arg_struct);
        return false;
    }
    if s1.verieasy_get() != s2.verieasy_get() {
        outputln!("MISMATCH: {}", "BitAlloc64K::dealloc");
        outputln!("contructor: {:?}", constr_arg_struct);
        outputln!("method: {:?}", method_arg_struct);
        return false;
    }
    true
}
#[inline(always)]
fn check_BitAlloc1M___dealloc(input: &[u8]) -> bool {
    let (constr_arg_struct, remain) =
        match ArgsBitAlloc1M___verieasy_new::take_from_bytes(&input[..]) {
            Ok((args, remain)) => (args, remain),
            Err(_) => return true,
        };
    let method_arg_struct = match postcard::from_bytes::<ArgsBitAlloc1M___dealloc>(&remain[..]) {
        Ok(args) => args,
        Err(_) => return true,
    };
    let mut s1 = mod1::BitAlloc1M::verieasy_new(constr_arg_struct.bitmap.clone());
    let mut s2 = mod2::BitAlloc1M::verieasy_new(constr_arg_struct.bitmap.clone());
    if !s2.verieasy_pre_dealloc(method_arg_struct.key.clone()) {
        return true;
    }
    let r1 = mod1::BitAlloc1M::dealloc(&mut s1, method_arg_struct.key.clone());
    let r2 = mod2::BitAlloc1M::dealloc(&mut s2, method_arg_struct.key.clone());
    if r1 != r2 {
        outputln!("MISMATCH: {}", "BitAlloc1M::dealloc");
        outputln!("contructor: {:?}", constr_arg_struct);
        outputln!("method: {:?}", method_arg_struct);
        return false;
    }
    if s1.verieasy_get() != s2.verieasy_get() {
        outputln!("MISMATCH: {}", "BitAlloc1M::dealloc");
        outputln!("contructor: {:?}", constr_arg_struct);
        outputln!("method: {:?}", method_arg_struct);
        return false;
    }
    true
}
#[inline(always)]
fn check_BitAlloc256___insert(input: &[u8]) -> bool {
    let (constr_arg_struct, remain) =
        match postcard::take_from_bytes::<ArgsBitAlloc256___verieasy_new>(&input[..]) {
            Ok((args, remain)) => (args, remain),
            Err(_) => return true,
        };
    let method_arg_struct = match postcard::from_bytes::<ArgsBitAlloc256___insert>(&remain[..]) {
        Ok(args) => args,
        Err(_) => return true,
    };
    let mut s1 = mod1::BitAlloc256::verieasy_new(constr_arg_struct.bitmap.clone());
    let mut s2 = mod2::BitAlloc256::verieasy_new(constr_arg_struct.bitmap.clone());
    if !s2.verieasy_pre_insert(method_arg_struct.range.clone()) {
        return true;
    }
    let r1 = mod1::BitAlloc256::insert(&mut s1, method_arg_struct.range.clone());
    let r2 = mod2::BitAlloc256::insert(&mut s2, method_arg_struct.range.clone());
    if r1 != r2 {
        outputln!("MISMATCH: {}", "BitAlloc256::insert");
        outputln!("contructor: {:?}", constr_arg_struct);
        outputln!("method: {:?}", method_arg_struct);
        return false;
    }
    if s1.verieasy_get() != s2.verieasy_get() {
        outputln!("MISMATCH: {}", "BitAlloc256::insert");
        outputln!("contructor: {:?}", constr_arg_struct);
        outputln!("method: {:?}", method_arg_struct);
        return false;
    }
    true
}
#[inline(always)]
fn check_BitAlloc4K___insert(input: &[u8]) -> bool {
    let (constr_arg_struct, remain) =
        match ArgsBitAlloc4K___verieasy_new::take_from_bytes(&input[..]) {
            Ok((args, remain)) => (args, remain),
            Err(_) => return true,
        };
    let method_arg_struct = match postcard::from_bytes::<ArgsBitAlloc4K___insert>(&remain[..]) {
        Ok(args) => args,
        Err(_) => return true,
    };
    let mut s1 = mod1::BitAlloc4K::verieasy_new(constr_arg_struct.bitmap.clone());
    let mut s2 = mod2::BitAlloc4K::verieasy_new(constr_arg_struct.bitmap.clone());
    if !s2.verieasy_pre_insert(method_arg_struct.range.clone()) {
        return true;
    }
    let r1 = mod1::BitAlloc4K::insert(&mut s1, method_arg_struct.range.clone());
    let r2 = mod2::BitAlloc4K::insert(&mut s2, method_arg_struct.range.clone());
    if r1 != r2 {
        outputln!("MISMATCH: {}", "BitAlloc4K::insert");
        outputln!("contructor: {:?}", constr_arg_struct);
        outputln!("method: {:?}", method_arg_struct);
        return false;
    }
    if s1.verieasy_get() != s2.verieasy_get() {
        outputln!("MISMATCH: {}", "BitAlloc4K::insert");
        outputln!("contructor: {:?}", constr_arg_struct);
        outputln!("method: {:?}", method_arg_struct);
        return false;
    }
    true
}
#[inline(always)]
fn check_BitAlloc64K___insert(input: &[u8]) -> bool {
    let (constr_arg_struct, remain) =
        match ArgsBitAlloc64K___verieasy_new::take_from_bytes(&input[..]) {
            Ok((args, remain)) => (args, remain),
            Err(_) => return true,
        };
    let method_arg_struct = match postcard::from_bytes::<ArgsBitAlloc64K___insert>(&remain[..]) {
        Ok(args) => args,
        Err(_) => return true,
    };
    let mut s1 = mod1::BitAlloc64K::verieasy_new(constr_arg_struct.bitmap.clone());
    let mut s2 = mod2::BitAlloc64K::verieasy_new(constr_arg_struct.bitmap.clone());
    if !s2.verieasy_pre_insert(method_arg_struct.range.clone()) {
        return true;
    }
    let r1 = mod1::BitAlloc64K::insert(&mut s1, method_arg_struct.range.clone());
    let r2 = mod2::BitAlloc64K::insert(&mut s2, method_arg_struct.range.clone());
    if r1 != r2 {
        outputln!("MISMATCH: {}", "BitAlloc64K::insert");
        outputln!("contructor: {:?}", constr_arg_struct);
        outputln!("method: {:?}", method_arg_struct);
        return false;
    }
    if s1.verieasy_get() != s2.verieasy_get() {
        outputln!("MISMATCH: {}", "BitAlloc64K::insert");
        outputln!("contructor: {:?}", constr_arg_struct);
        outputln!("method: {:?}", method_arg_struct);
        return false;
    }
    true
}
#[inline(always)]
fn check_BitAlloc1M___insert(input: &[u8]) -> bool {
    let (constr_arg_struct, remain) =
        match ArgsBitAlloc1M___verieasy_new::take_from_bytes(&input[..]) {
            Ok((args, remain)) => (args, remain),
            Err(_) => return true,
        };
    let method_arg_struct = match postcard::from_bytes::<ArgsBitAlloc1M___insert>(&remain[..]) {
        Ok(args) => args,
        Err(_) => return true,
    };
    let mut s1 = mod1::BitAlloc1M::verieasy_new(constr_arg_struct.bitmap.clone());
    let mut s2 = mod2::BitAlloc1M::verieasy_new(constr_arg_struct.bitmap.clone());
    if !s2.verieasy_pre_insert(method_arg_struct.range.clone()) {
        return true;
    }
    let r1 = mod1::BitAlloc1M::insert(&mut s1, method_arg_struct.range.clone());
    let r2 = mod2::BitAlloc1M::insert(&mut s2, method_arg_struct.range.clone());
    if r1 != r2 {
        outputln!("MISMATCH: {}", "BitAlloc1M::insert");
        outputln!("contructor: {:?}", constr_arg_struct);
        outputln!("method: {:?}", method_arg_struct);
        return false;
    }
    if s1.verieasy_get() != s2.verieasy_get() {
        outputln!("MISMATCH: {}", "BitAlloc1M::insert");
        outputln!("contructor: {:?}", constr_arg_struct);
        outputln!("method: {:?}", method_arg_struct);
        return false;
    }
    true
}
#[inline(always)]
fn check_BitAlloc256___remove(input: &[u8]) -> bool {
    let (constr_arg_struct, remain) =
        match postcard::take_from_bytes::<ArgsBitAlloc256___verieasy_new>(&input[..]) {
            Ok((args, remain)) => (args, remain),
            Err(_) => return true,
        };
    let method_arg_struct = match postcard::from_bytes::<ArgsBitAlloc256___remove>(&remain[..]) {
        Ok(args) => args,
        Err(_) => return true,
    };
    let mut s1 = mod1::BitAlloc256::verieasy_new(constr_arg_struct.bitmap.clone());
    let mut s2 = mod2::BitAlloc256::verieasy_new(constr_arg_struct.bitmap.clone());
    if !s2.verieasy_pre_remove(method_arg_struct.range.clone()) {
        return true;
    }
    let r1 = mod1::BitAlloc256::remove(&mut s1, method_arg_struct.range.clone());
    let r2 = mod2::BitAlloc256::remove(&mut s2, method_arg_struct.range.clone());
    if r1 != r2 {
        outputln!("MISMATCH: {}", "BitAlloc256::remove");
        outputln!("contructor: {:?}", constr_arg_struct);
        outputln!("method: {:?}", method_arg_struct);
        return false;
    }
    if s1.verieasy_get() != s2.verieasy_get() {
        outputln!("MISMATCH: {}", "BitAlloc256::remove");
        outputln!("contructor: {:?}", constr_arg_struct);
        outputln!("method: {:?}", method_arg_struct);
        return false;
    }
    true
}
#[inline(always)]
fn check_BitAlloc4K___remove(input: &[u8]) -> bool {
    let (constr_arg_struct, remain) =
        match ArgsBitAlloc4K___verieasy_new::take_from_bytes(&input[..]) {
            Ok((args, remain)) => (args, remain),
            Err(_) => return true,
        };
    let method_arg_struct = match postcard::from_bytes::<ArgsBitAlloc4K___remove>(&remain[..]) {
        Ok(args) => args,
        Err(_) => return true,
    };
    let mut s1 = mod1::BitAlloc4K::verieasy_new(constr_arg_struct.bitmap.clone());
    let mut s2 = mod2::BitAlloc4K::verieasy_new(constr_arg_struct.bitmap.clone());
    if !s2.verieasy_pre_remove(method_arg_struct.range.clone()) {
        return true;
    }
    let r1 = mod1::BitAlloc4K::remove(&mut s1, method_arg_struct.range.clone());
    let r2 = mod2::BitAlloc4K::remove(&mut s2, method_arg_struct.range.clone());
    if r1 != r2 {
        outputln!("MISMATCH: {}", "BitAlloc4K::remove");
        outputln!("contructor: {:?}", constr_arg_struct);
        outputln!("method: {:?}", method_arg_struct);
        return false;
    }
    if s1.verieasy_get() != s2.verieasy_get() {
        outputln!("MISMATCH: {}", "BitAlloc4K::remove");
        outputln!("contructor: {:?}", constr_arg_struct);
        outputln!("method: {:?}", method_arg_struct);
        return false;
    }
    true
}
#[inline(always)]
fn check_BitAlloc64K___remove(input: &[u8]) -> bool {
    let (constr_arg_struct, remain) =
        match ArgsBitAlloc64K___verieasy_new::take_from_bytes(&input[..]) {
            Ok((args, remain)) => (args, remain),
            Err(_) => return true,
        };
    let method_arg_struct = match postcard::from_bytes::<ArgsBitAlloc64K___remove>(&remain[..]) {
        Ok(args) => args,
        Err(_) => return true,
    };
    let mut s1 = mod1::BitAlloc64K::verieasy_new(constr_arg_struct.bitmap.clone());
    let mut s2 = mod2::BitAlloc64K::verieasy_new(constr_arg_struct.bitmap.clone());
    if !s2.verieasy_pre_remove(method_arg_struct.range.clone()) {
        return true;
    }
    let r1 = mod1::BitAlloc64K::remove(&mut s1, method_arg_struct.range.clone());
    let r2 = mod2::BitAlloc64K::remove(&mut s2, method_arg_struct.range.clone());
    if r1 != r2 {
        outputln!("MISMATCH: {}", "BitAlloc64K::remove");
        outputln!("contructor: {:?}", constr_arg_struct);
        outputln!("method: {:?}", method_arg_struct);
        return false;
    }
    if s1.verieasy_get() != s2.verieasy_get() {
        outputln!("MISMATCH: {}", "BitAlloc64K::remove");
        outputln!("contructor: {:?}", constr_arg_struct);
        outputln!("method: {:?}", method_arg_struct);
        return false;
    }
    true
}
#[inline(always)]
fn check_BitAlloc1M___remove(input: &[u8]) -> bool {
    let (constr_arg_struct, remain) =
        match ArgsBitAlloc1M___verieasy_new::take_from_bytes(&input[..]) {
            Ok((args, remain)) => (args, remain),
            Err(_) => return true,
        };
    let method_arg_struct = match postcard::from_bytes::<ArgsBitAlloc1M___remove>(&remain[..]) {
        Ok(args) => args,
        Err(_) => return true,
    };
    let mut s1 = mod1::BitAlloc1M::verieasy_new(constr_arg_struct.bitmap.clone());
    let mut s2 = mod2::BitAlloc1M::verieasy_new(constr_arg_struct.bitmap.clone());
    if !s2.verieasy_pre_remove(method_arg_struct.range.clone()) {
        return true;
    }
    let r1 = mod1::BitAlloc1M::remove(&mut s1, method_arg_struct.range.clone());
    let r2 = mod2::BitAlloc1M::remove(&mut s2, method_arg_struct.range.clone());
    if r1 != r2 {
        outputln!("MISMATCH: {}", "BitAlloc1M::remove");
        outputln!("contructor: {:?}", constr_arg_struct);
        outputln!("method: {:?}", method_arg_struct);
        return false;
    }
    if s1.verieasy_get() != s2.verieasy_get() {
        outputln!("MISMATCH: {}", "BitAlloc1M::remove");
        outputln!("contructor: {:?}", constr_arg_struct);
        outputln!("method: {:?}", method_arg_struct);
        return false;
    }
    true
}
#[inline(always)]
fn check_BitAlloc256___any(input: &[u8]) -> bool {
    let (constr_arg_struct, remain) =
        match postcard::take_from_bytes::<ArgsBitAlloc256___verieasy_new>(&input[..]) {
            Ok((args, remain)) => (args, remain),
            Err(_) => return true,
        };
    let method_arg_struct = match postcard::from_bytes::<ArgsBitAlloc256___any>(&remain[..]) {
        Ok(args) => args,
        Err(_) => return true,
    };
    let mut s1 = mod1::BitAlloc256::verieasy_new(constr_arg_struct.bitmap.clone());
    let mut s2 = mod2::BitAlloc256::verieasy_new(constr_arg_struct.bitmap.clone());
    let r1 = mod1::BitAlloc256::any(&s1);
    let r2 = mod2::BitAlloc256::any(&s2);
    if r1 != r2 {
        outputln!("MISMATCH: {}", "BitAlloc256::any");
        outputln!("contructor: {:?}", constr_arg_struct);
        outputln!("method: {:?}", method_arg_struct);
        return false;
    }
    if s1.verieasy_get() != s2.verieasy_get() {
        outputln!("MISMATCH: {}", "BitAlloc256::any");
        outputln!("contructor: {:?}", constr_arg_struct);
        outputln!("method: {:?}", method_arg_struct);
        return false;
    }
    true
}
#[inline(always)]
fn check_BitAlloc4K___any(input: &[u8]) -> bool {
    let (constr_arg_struct, remain) =
        match ArgsBitAlloc4K___verieasy_new::take_from_bytes(&input[..]) {
            Ok((args, remain)) => (args, remain),
            Err(_) => return true,
        };
    let method_arg_struct = match postcard::from_bytes::<ArgsBitAlloc4K___any>(&remain[..]) {
        Ok(args) => args,
        Err(_) => return true,
    };
    let mut s1 = mod1::BitAlloc4K::verieasy_new(constr_arg_struct.bitmap.clone());
    let mut s2 = mod2::BitAlloc4K::verieasy_new(constr_arg_struct.bitmap.clone());
    let r1 = mod1::BitAlloc4K::any(&s1);
    let r2 = mod2::BitAlloc4K::any(&s2);
    if r1 != r2 {
        outputln!("MISMATCH: {}", "BitAlloc4K::any");
        outputln!("contructor: {:?}", constr_arg_struct);
        outputln!("method: {:?}", method_arg_struct);
        return false;
    }
    if s1.verieasy_get() != s2.verieasy_get() {
        outputln!("MISMATCH: {}", "BitAlloc4K::any");
        outputln!("contructor: {:?}", constr_arg_struct);
        outputln!("method: {:?}", method_arg_struct);
        return false;
    }
    true
}
#[inline(always)]
fn check_BitAlloc64K___any(input: &[u8]) -> bool {
    let (constr_arg_struct, remain) =
        match ArgsBitAlloc64K___verieasy_new::take_from_bytes(&input[..]) {
            Ok((args, remain)) => (args, remain),
            Err(_) => return true,
        };
    let method_arg_struct = match postcard::from_bytes::<ArgsBitAlloc64K___any>(&remain[..]) {
        Ok(args) => args,
        Err(_) => return true,
    };
    let mut s1 = mod1::BitAlloc64K::verieasy_new(constr_arg_struct.bitmap.clone());
    let mut s2 = mod2::BitAlloc64K::verieasy_new(constr_arg_struct.bitmap.clone());
    let r1 = mod1::BitAlloc64K::any(&s1);
    let r2 = mod2::BitAlloc64K::any(&s2);
    if r1 != r2 {
        outputln!("MISMATCH: {}", "BitAlloc64K::any");
        outputln!("contructor: {:?}", constr_arg_struct);
        outputln!("method: {:?}", method_arg_struct);
        return false;
    }
    if s1.verieasy_get() != s2.verieasy_get() {
        outputln!("MISMATCH: {}", "BitAlloc64K::any");
        outputln!("contructor: {:?}", constr_arg_struct);
        outputln!("method: {:?}", method_arg_struct);
        return false;
    }
    true
}
#[inline(always)]
fn check_BitAlloc1M___any(input: &[u8]) -> bool {
    let (constr_arg_struct, remain) =
        match ArgsBitAlloc1M___verieasy_new::take_from_bytes(&input[..]) {
            Ok((args, remain)) => (args, remain),
            Err(_) => return true,
        };
    let method_arg_struct = match postcard::from_bytes::<ArgsBitAlloc1M___any>(&remain[..]) {
        Ok(args) => args,
        Err(_) => return true,
    };
    let mut s1 = mod1::BitAlloc1M::verieasy_new(constr_arg_struct.bitmap.clone());
    let mut s2 = mod2::BitAlloc1M::verieasy_new(constr_arg_struct.bitmap.clone());
    let r1 = mod1::BitAlloc1M::any(&s1);
    let r2 = mod2::BitAlloc1M::any(&s2);
    if r1 != r2 {
        outputln!("MISMATCH: {}", "BitAlloc1M::any");
        outputln!("contructor: {:?}", constr_arg_struct);
        outputln!("method: {:?}", method_arg_struct);
        return false;
    }
    if s1.verieasy_get() != s2.verieasy_get() {
        outputln!("MISMATCH: {}", "BitAlloc1M::any");
        outputln!("contructor: {:?}", constr_arg_struct);
        outputln!("method: {:?}", method_arg_struct);
        return false;
    }
    true
}
#[inline(always)]
fn check_BitAlloc256___test(input: &[u8]) -> bool {
    let (constr_arg_struct, remain) =
        match postcard::take_from_bytes::<ArgsBitAlloc256___verieasy_new>(&input[..]) {
            Ok((args, remain)) => (args, remain),
            Err(_) => return true,
        };
    let method_arg_struct = match postcard::from_bytes::<ArgsBitAlloc256___test>(&remain[..]) {
        Ok(args) => args,
        Err(_) => return true,
    };
    let mut s1 = mod1::BitAlloc256::verieasy_new(constr_arg_struct.bitmap.clone());
    let mut s2 = mod2::BitAlloc256::verieasy_new(constr_arg_struct.bitmap.clone());
    if !s2.verieasy_pre_test(method_arg_struct.key.clone()) {
        return true;
    }
    let r1 = mod1::BitAlloc256::test(&s1, method_arg_struct.key.clone());
    let r2 = mod2::BitAlloc256::test(&s2, method_arg_struct.key.clone());
    if r1 != r2 {
        outputln!("MISMATCH: {}", "BitAlloc256::test");
        outputln!("contructor: {:?}", constr_arg_struct);
        outputln!("method: {:?}", method_arg_struct);
        return false;
    }
    if s1.verieasy_get() != s2.verieasy_get() {
        outputln!("MISMATCH: {}", "BitAlloc256::test");
        outputln!("contructor: {:?}", constr_arg_struct);
        outputln!("method: {:?}", method_arg_struct);
        return false;
    }
    true
}
#[inline(always)]
fn check_BitAlloc4K___test(input: &[u8]) -> bool {
    let (constr_arg_struct, remain) =
        match ArgsBitAlloc4K___verieasy_new::take_from_bytes(&input[..]) {
            Ok((args, remain)) => (args, remain),
            Err(_) => return true,
        };
    let method_arg_struct = match postcard::from_bytes::<ArgsBitAlloc4K___test>(&remain[..]) {
        Ok(args) => args,
        Err(_) => return true,
    };
    let mut s1 = mod1::BitAlloc4K::verieasy_new(constr_arg_struct.bitmap.clone());
    let mut s2 = mod2::BitAlloc4K::verieasy_new(constr_arg_struct.bitmap.clone());
    if !s2.verieasy_pre_test(method_arg_struct.key.clone()) {
        return true;
    }
    let r1 = mod1::BitAlloc4K::test(&s1, method_arg_struct.key.clone());
    let r2 = mod2::BitAlloc4K::test(&s2, method_arg_struct.key.clone());
    if r1 != r2 {
        outputln!("MISMATCH: {}", "BitAlloc4K::test");
        outputln!("contructor: {:?}", constr_arg_struct);
        outputln!("method: {:?}", method_arg_struct);
        return false;
    }
    if s1.verieasy_get() != s2.verieasy_get() {
        outputln!("MISMATCH: {}", "BitAlloc4K::test");
        outputln!("contructor: {:?}", constr_arg_struct);
        outputln!("method: {:?}", method_arg_struct);
        return false;
    }
    true
}
#[inline(always)]
fn check_BitAlloc64K___test(input: &[u8]) -> bool {
    let (constr_arg_struct, remain) =
        match ArgsBitAlloc64K___verieasy_new::take_from_bytes(&input[..]) {
            Ok((args, remain)) => (args, remain),
            Err(_) => return true,
        };
    let method_arg_struct = match postcard::from_bytes::<ArgsBitAlloc64K___test>(&remain[..]) {
        Ok(args) => args,
        Err(_) => return true,
    };
    let mut s1 = mod1::BitAlloc64K::verieasy_new(constr_arg_struct.bitmap.clone());
    let mut s2 = mod2::BitAlloc64K::verieasy_new(constr_arg_struct.bitmap.clone());
    if !s2.verieasy_pre_test(method_arg_struct.key.clone()) {
        return true;
    }
    let r1 = mod1::BitAlloc64K::test(&s1, method_arg_struct.key.clone());
    let r2 = mod2::BitAlloc64K::test(&s2, method_arg_struct.key.clone());
    if r1 != r2 {
        outputln!("MISMATCH: {}", "BitAlloc64K::test");
        outputln!("contructor: {:?}", constr_arg_struct);
        outputln!("method: {:?}", method_arg_struct);
        return false;
    }
    if s1.verieasy_get() != s2.verieasy_get() {
        outputln!("MISMATCH: {}", "BitAlloc64K::test");
        outputln!("contructor: {:?}", constr_arg_struct);
        outputln!("method: {:?}", method_arg_struct);
        return false;
    }
    true
}
#[inline(always)]
fn check_BitAlloc1M___test(input: &[u8]) -> bool {
    let (constr_arg_struct, remain) =
        match ArgsBitAlloc1M___verieasy_new::take_from_bytes(&input[..]) {
            Ok((args, remain)) => (args, remain),
            Err(_) => return true,
        };
    let method_arg_struct = match postcard::from_bytes::<ArgsBitAlloc1M___test>(&remain[..]) {
        Ok(args) => args,
        Err(_) => return true,
    };
    let mut s1 = mod1::BitAlloc1M::verieasy_new(constr_arg_struct.bitmap.clone());
    let mut s2 = mod2::BitAlloc1M::verieasy_new(constr_arg_struct.bitmap.clone());
    if !s2.verieasy_pre_test(method_arg_struct.key.clone()) {
        return true;
    }
    let r1 = mod1::BitAlloc1M::test(&s1, method_arg_struct.key.clone());
    let r2 = mod2::BitAlloc1M::test(&s2, method_arg_struct.key.clone());
    if r1 != r2 {
        outputln!("MISMATCH: {}", "BitAlloc1M::test");
        outputln!("contructor: {:?}", constr_arg_struct);
        outputln!("method: {:?}", method_arg_struct);
        return false;
    }
    if s1.verieasy_get() != s2.verieasy_get() {
        outputln!("MISMATCH: {}", "BitAlloc1M::test");
        outputln!("contructor: {:?}", constr_arg_struct);
        outputln!("method: {:?}", method_arg_struct);
        return false;
    }
    true
}
#[inline(always)]
fn check_BitAlloc256___next(input: &[u8]) -> bool {
    let (constr_arg_struct, remain) =
        match postcard::take_from_bytes::<ArgsBitAlloc256___verieasy_new>(&input[..]) {
            Ok((args, remain)) => (args, remain),
            Err(_) => return true,
        };
    let method_arg_struct = match postcard::from_bytes::<ArgsBitAlloc256___next>(&remain[..]) {
        Ok(args) => args,
        Err(_) => return true,
    };
    let mut s1 = mod1::BitAlloc256::verieasy_new(constr_arg_struct.bitmap.clone());
    let mut s2 = mod2::BitAlloc256::verieasy_new(constr_arg_struct.bitmap.clone());
    if !s2.verieasy_pre_next(method_arg_struct.key.clone()) {
        return true;
    }
    let r1 = mod1::BitAlloc256::next(&s1, method_arg_struct.key.clone());
    let r2 = mod2::BitAlloc256::next(&s2, method_arg_struct.key.clone());
    if r1 != r2 {
        outputln!("MISMATCH: {}", "BitAlloc256::next");
        outputln!("contructor: {:?}", constr_arg_struct);
        outputln!("method: {:?}", method_arg_struct);
        return false;
    }
    if s1.verieasy_get() != s2.verieasy_get() {
        outputln!("MISMATCH: {}", "BitAlloc256::next");
        outputln!("contructor: {:?}", constr_arg_struct);
        outputln!("method: {:?}", method_arg_struct);
        return false;
    }
    true
}
#[inline(always)]
fn check_BitAlloc4K___next(input: &[u8]) -> bool {
    let (constr_arg_struct, remain) =
        match ArgsBitAlloc4K___verieasy_new::take_from_bytes(&input[..]) {
            Ok((args, remain)) => (args, remain),
            Err(_) => return true,
        };
    let method_arg_struct = match postcard::from_bytes::<ArgsBitAlloc4K___next>(&remain[..]) {
        Ok(args) => args,
        Err(_) => return true,
    };
    let mut s1 = mod1::BitAlloc4K::verieasy_new(constr_arg_struct.bitmap.clone());
    let mut s2 = mod2::BitAlloc4K::verieasy_new(constr_arg_struct.bitmap.clone());
    if !s2.verieasy_pre_next(method_arg_struct.key.clone()) {
        return true;
    }
    let r1 = mod1::BitAlloc4K::next(&s1, method_arg_struct.key.clone());
    let r2 = mod2::BitAlloc4K::next(&s2, method_arg_struct.key.clone());
    if r1 != r2 {
        outputln!("MISMATCH: {}", "BitAlloc4K::next");
        outputln!("contructor: {:?}", constr_arg_struct);
        outputln!("method: {:?}", method_arg_struct);
        return false;
    }
    if s1.verieasy_get() != s2.verieasy_get() {
        outputln!("MISMATCH: {}", "BitAlloc4K::next");
        outputln!("contructor: {:?}", constr_arg_struct);
        outputln!("method: {:?}", method_arg_struct);
        return false;
    }
    true
}
#[inline(always)]
fn check_BitAlloc64K___next(input: &[u8]) -> bool {
    let (constr_arg_struct, remain) =
        match ArgsBitAlloc64K___verieasy_new::take_from_bytes(&input[..]) {
            Ok((args, remain)) => (args, remain),
            Err(_) => return true,
        };
    let method_arg_struct = match postcard::from_bytes::<ArgsBitAlloc64K___next>(&remain[..]) {
        Ok(args) => args,
        Err(_) => return true,
    };
    let mut s1 = mod1::BitAlloc64K::verieasy_new(constr_arg_struct.bitmap.clone());
    let mut s2 = mod2::BitAlloc64K::verieasy_new(constr_arg_struct.bitmap.clone());
    if !s2.verieasy_pre_next(method_arg_struct.key.clone()) {
        return true;
    }
    let r1 = mod1::BitAlloc64K::next(&s1, method_arg_struct.key.clone());
    let r2 = mod2::BitAlloc64K::next(&s2, method_arg_struct.key.clone());
    if r1 != r2 {
        outputln!("MISMATCH: {}", "BitAlloc64K::next");
        outputln!("contructor: {:?}", constr_arg_struct);
        outputln!("method: {:?}", method_arg_struct);
        return false;
    }
    if s1.verieasy_get() != s2.verieasy_get() {
        outputln!("MISMATCH: {}", "BitAlloc64K::next");
        outputln!("contructor: {:?}", constr_arg_struct);
        outputln!("method: {:?}", method_arg_struct);
        return false;
    }
    true
}
#[inline(always)]
fn check_BitAlloc1M___next(input: &[u8]) -> bool {
    let (constr_arg_struct, remain) =
        match ArgsBitAlloc1M___verieasy_new::take_from_bytes(&input[..]) {
            Ok((args, remain)) => (args, remain),
            Err(_) => return true,
        };
    let method_arg_struct = match postcard::from_bytes::<ArgsBitAlloc1M___next>(&remain[..]) {
        Ok(args) => args,
        Err(_) => return true,
    };
    let mut s1 = mod1::BitAlloc1M::verieasy_new(constr_arg_struct.bitmap.clone());
    let mut s2 = mod2::BitAlloc1M::verieasy_new(constr_arg_struct.bitmap.clone());
    if !s2.verieasy_pre_next(method_arg_struct.key.clone()) {
        return true;
    }
    let r1 = mod1::BitAlloc1M::next(&s1, method_arg_struct.key.clone());
    let r2 = mod2::BitAlloc1M::next(&s2, method_arg_struct.key.clone());
    if r1 != r2 {
        outputln!("MISMATCH: {}", "BitAlloc1M::next");
        outputln!("contructor: {:?}", constr_arg_struct);
        outputln!("method: {:?}", method_arg_struct);
        return false;
    }
    if s1.verieasy_get() != s2.verieasy_get() {
        outputln!("MISMATCH: {}", "BitAlloc1M::next");
        outputln!("contructor: {:?}", constr_arg_struct);
        outputln!("method: {:?}", method_arg_struct);
        return false;
    }
    true
}
#[inline(always)]
fn check_BitAlloc16___alloc(input: &[u8]) -> bool {
    let (constr_arg_struct, remain) =
        match postcard::take_from_bytes::<ArgsBitAlloc16___verieasy_new>(&input[..]) {
            Ok((args, remain)) => (args, remain),
            Err(_) => return true,
        };
    let method_arg_struct = match postcard::from_bytes::<ArgsBitAlloc16___alloc>(&remain[..]) {
        Ok(args) => args,
        Err(_) => return true,
    };
    let mut s1 = mod1::BitAlloc16::verieasy_new(constr_arg_struct.bits.clone());
    let mut s2 = mod2::BitAlloc16::verieasy_new(constr_arg_struct.bits.clone());
    if !s2.verieasy_pre_alloc() {
        return true;
    }
    let r1 = mod1::BitAlloc16::alloc(&mut s1);
    let r2 = mod2::BitAlloc16::alloc(&mut s2);
    if r1 != r2 {
        outputln!("MISMATCH: {}", "BitAlloc16::alloc");
        outputln!("contructor: {:?}", constr_arg_struct);
        outputln!("method: {:?}", method_arg_struct);
        return false;
    }
    if s1.verieasy_get() != s2.verieasy_get() {
        outputln!("MISMATCH: {}", "BitAlloc16::alloc");
        outputln!("contructor: {:?}", constr_arg_struct);
        outputln!("method: {:?}", method_arg_struct);
        return false;
    }
    true
}
#[inline(always)]
fn check_BitAlloc16___alloc_contiguous(input: &[u8]) -> bool {
    let (constr_arg_struct, remain) =
        match postcard::take_from_bytes::<ArgsBitAlloc16___verieasy_new>(&input[..]) {
            Ok((args, remain)) => (args, remain),
            Err(_) => return true,
        };
    let method_arg_struct =
        match postcard::from_bytes::<ArgsBitAlloc16___alloc_contiguous>(&remain[..]) {
            Ok(args) => args,
            Err(_) => return true,
        };
    let mut s1 = mod1::BitAlloc16::verieasy_new(constr_arg_struct.bits.clone());
    let mut s2 = mod2::BitAlloc16::verieasy_new(constr_arg_struct.bits.clone());
    if !s2.verieasy_pre_alloc_contiguous(
        method_arg_struct.size.clone(),
        method_arg_struct.align_log2.clone(),
    ) {
        return true;
    }
    let r1 = mod1::BitAlloc16::alloc_contiguous(
        &mut s1,
        method_arg_struct.size.clone(),
        method_arg_struct.align_log2.clone(),
    );
    let r2 = mod2::BitAlloc16::alloc_contiguous(
        &mut s2,
        method_arg_struct.size.clone(),
        method_arg_struct.align_log2.clone(),
    );
    if r1 != r2 {
        outputln!("MISMATCH: {}", "BitAlloc16::alloc_contiguous");
        outputln!("contructor: {:?}", constr_arg_struct);
        outputln!("method: {:?}", method_arg_struct);
        return false;
    }
    if s1.verieasy_get() != s2.verieasy_get() {
        outputln!("MISMATCH: {}", "BitAlloc16::alloc_contiguous");
        outputln!("contructor: {:?}", constr_arg_struct);
        outputln!("method: {:?}", method_arg_struct);
        return false;
    }
    true
}
#[inline(always)]
fn check_BitAlloc16___dealloc(input: &[u8]) -> bool {
    let (constr_arg_struct, remain) =
        match postcard::take_from_bytes::<ArgsBitAlloc16___verieasy_new>(&input[..]) {
            Ok((args, remain)) => (args, remain),
            Err(_) => return true,
        };
    let method_arg_struct = match postcard::from_bytes::<ArgsBitAlloc16___dealloc>(&remain[..]) {
        Ok(args) => args,
        Err(_) => return true,
    };
    let mut s1 = mod1::BitAlloc16::verieasy_new(constr_arg_struct.bits.clone());
    let mut s2 = mod2::BitAlloc16::verieasy_new(constr_arg_struct.bits.clone());
    if !s2.verieasy_pre_dealloc(method_arg_struct.key.clone()) {
        return true;
    }
    let r1 = mod1::BitAlloc16::dealloc(&mut s1, method_arg_struct.key.clone());
    let r2 = mod2::BitAlloc16::dealloc(&mut s2, method_arg_struct.key.clone());
    if r1 != r2 {
        outputln!("MISMATCH: {}", "BitAlloc16::dealloc");
        outputln!("contructor: {:?}", constr_arg_struct);
        outputln!("method: {:?}", method_arg_struct);
        return false;
    }
    if s1.verieasy_get() != s2.verieasy_get() {
        outputln!("MISMATCH: {}", "BitAlloc16::dealloc");
        outputln!("contructor: {:?}", constr_arg_struct);
        outputln!("method: {:?}", method_arg_struct);
        return false;
    }
    true
}
#[inline(always)]
fn check_BitAlloc16___insert(input: &[u8]) -> bool {
    let (constr_arg_struct, remain) =
        match postcard::take_from_bytes::<ArgsBitAlloc16___verieasy_new>(&input[..]) {
            Ok((args, remain)) => (args, remain),
            Err(_) => return true,
        };
    let method_arg_struct = match postcard::from_bytes::<ArgsBitAlloc16___insert>(&remain[..]) {
        Ok(args) => args,
        Err(_) => return true,
    };
    let mut s1 = mod1::BitAlloc16::verieasy_new(constr_arg_struct.bits.clone());
    let mut s2 = mod2::BitAlloc16::verieasy_new(constr_arg_struct.bits.clone());
    if !s2.verieasy_pre_insert(method_arg_struct.range.clone()) {
        return true;
    }
    let r1 = mod1::BitAlloc16::insert(&mut s1, method_arg_struct.range.clone());
    let r2 = mod2::BitAlloc16::insert(&mut s2, method_arg_struct.range.clone());
    if r1 != r2 {
        outputln!("MISMATCH: {}", "BitAlloc16::insert");
        outputln!("contructor: {:?}", constr_arg_struct);
        outputln!("method: {:?}", method_arg_struct);
        return false;
    }
    if s1.verieasy_get() != s2.verieasy_get() {
        outputln!("MISMATCH: {}", "BitAlloc16::insert");
        outputln!("contructor: {:?}", constr_arg_struct);
        outputln!("method: {:?}", method_arg_struct);
        return false;
    }
    true
}
#[inline(always)]
fn check_BitAlloc16___remove(input: &[u8]) -> bool {
    let (constr_arg_struct, remain) =
        match postcard::take_from_bytes::<ArgsBitAlloc16___verieasy_new>(&input[..]) {
            Ok((args, remain)) => (args, remain),
            Err(_) => return true,
        };
    let method_arg_struct = match postcard::from_bytes::<ArgsBitAlloc16___remove>(&remain[..]) {
        Ok(args) => args,
        Err(_) => return true,
    };
    let mut s1 = mod1::BitAlloc16::verieasy_new(constr_arg_struct.bits.clone());
    let mut s2 = mod2::BitAlloc16::verieasy_new(constr_arg_struct.bits.clone());
    if !s2.verieasy_pre_remove(method_arg_struct.range.clone()) {
        return true;
    }
    let r1 = mod1::BitAlloc16::remove(&mut s1, method_arg_struct.range.clone());
    let r2 = mod2::BitAlloc16::remove(&mut s2, method_arg_struct.range.clone());
    if r1 != r2 {
        outputln!("MISMATCH: {}", "BitAlloc16::remove");
        outputln!("contructor: {:?}", constr_arg_struct);
        outputln!("method: {:?}", method_arg_struct);
        return false;
    }
    if s1.verieasy_get() != s2.verieasy_get() {
        outputln!("MISMATCH: {}", "BitAlloc16::remove");
        outputln!("contructor: {:?}", constr_arg_struct);
        outputln!("method: {:?}", method_arg_struct);
        return false;
    }
    true
}
#[inline(always)]
fn check_BitAlloc16___any(input: &[u8]) -> bool {
    let (constr_arg_struct, remain) =
        match postcard::take_from_bytes::<ArgsBitAlloc16___verieasy_new>(&input[..]) {
            Ok((args, remain)) => (args, remain),
            Err(_) => return true,
        };
    let method_arg_struct = match postcard::from_bytes::<ArgsBitAlloc16___any>(&remain[..]) {
        Ok(args) => args,
        Err(_) => return true,
    };
    let mut s1 = mod1::BitAlloc16::verieasy_new(constr_arg_struct.bits.clone());
    let mut s2 = mod2::BitAlloc16::verieasy_new(constr_arg_struct.bits.clone());
    let r1 = mod1::BitAlloc16::any(&s1);
    let r2 = mod2::BitAlloc16::any(&s2);
    if r1 != r2 {
        outputln!("MISMATCH: {}", "BitAlloc16::any");
        outputln!("contructor: {:?}", constr_arg_struct);
        outputln!("method: {:?}", method_arg_struct);
        return false;
    }
    if s1.verieasy_get() != s2.verieasy_get() {
        outputln!("MISMATCH: {}", "BitAlloc16::any");
        outputln!("contructor: {:?}", constr_arg_struct);
        outputln!("method: {:?}", method_arg_struct);
        return false;
    }
    true
}
#[inline(always)]
fn check_BitAlloc16___test(input: &[u8]) -> bool {
    let (constr_arg_struct, remain) =
        match postcard::take_from_bytes::<ArgsBitAlloc16___verieasy_new>(&input[..]) {
            Ok((args, remain)) => (args, remain),
            Err(_) => return true,
        };
    let method_arg_struct = match postcard::from_bytes::<ArgsBitAlloc16___test>(&remain[..]) {
        Ok(args) => args,
        Err(_) => return true,
    };
    let mut s1 = mod1::BitAlloc16::verieasy_new(constr_arg_struct.bits.clone());
    let mut s2 = mod2::BitAlloc16::verieasy_new(constr_arg_struct.bits.clone());
    if !s2.verieasy_pre_test(method_arg_struct.key.clone()) {
        return true;
    }
    let r1 = mod1::BitAlloc16::test(&s1, method_arg_struct.key.clone());
    let r2 = mod2::BitAlloc16::test(&s2, method_arg_struct.key.clone());
    if r1 != r2 {
        outputln!("MISMATCH: {}", "BitAlloc16::test");
        outputln!("contructor: {:?}", constr_arg_struct);
        outputln!("method: {:?}", method_arg_struct);
        return false;
    }
    if s1.verieasy_get() != s2.verieasy_get() {
        outputln!("MISMATCH: {}", "BitAlloc16::test");
        outputln!("contructor: {:?}", constr_arg_struct);
        outputln!("method: {:?}", method_arg_struct);
        return false;
    }
    true
}
#[inline(always)]
fn check_BitAlloc16___next(input: &[u8]) -> bool {
    let (constr_arg_struct, remain) =
        match postcard::take_from_bytes::<ArgsBitAlloc16___verieasy_new>(&input[..]) {
            Ok((args, remain)) => (args, remain),
            Err(_) => return true,
        };
    let method_arg_struct = match postcard::from_bytes::<ArgsBitAlloc16___next>(&remain[..]) {
        Ok(args) => args,
        Err(_) => return true,
    };
    let mut s1 = mod1::BitAlloc16::verieasy_new(constr_arg_struct.bits.clone());
    let mut s2 = mod2::BitAlloc16::verieasy_new(constr_arg_struct.bits.clone());
    if !s2.verieasy_pre_next(method_arg_struct.key.clone()) {
        return true;
    }
    let r1 = mod1::BitAlloc16::next(&s1, method_arg_struct.key.clone());
    let r2 = mod2::BitAlloc16::next(&s2, method_arg_struct.key.clone());
    if r1 != r2 {
        outputln!("MISMATCH: {}", "BitAlloc16::next");
        outputln!("contructor: {:?}", constr_arg_struct);
        outputln!("method: {:?}", method_arg_struct);
        return false;
    }
    if s1.verieasy_get() != s2.verieasy_get() {
        outputln!("MISMATCH: {}", "BitAlloc16::next");
        outputln!("contructor: {:?}", constr_arg_struct);
        outputln!("method: {:?}", method_arg_struct);
        return false;
    }
    true
}
fn run_harness(input: &[u8]) -> bool {
    if input.len() == 0 {
        return true;
    }
    let fn_id = input[0] % 40usize as u8;
    match fn_id {
        0u8 => check_BitAlloc256___alloc(&input[1..]),
        1u8 => check_BitAlloc4K___alloc(&input[1..]),
        2u8 => check_BitAlloc64K___alloc(&input[1..]),
        3u8 => check_BitAlloc1M___alloc(&input[1..]),
        4u8 => check_BitAlloc256___alloc_contiguous(&input[1..]),
        5u8 => check_BitAlloc4K___alloc_contiguous(&input[1..]),
        6u8 => check_BitAlloc64K___alloc_contiguous(&input[1..]),
        7u8 => check_BitAlloc1M___alloc_contiguous(&input[1..]),
        8u8 => check_BitAlloc256___dealloc(&input[1..]),
        9u8 => check_BitAlloc4K___dealloc(&input[1..]),
        10u8 => check_BitAlloc64K___dealloc(&input[1..]),
        11u8 => check_BitAlloc1M___dealloc(&input[1..]),
        12u8 => check_BitAlloc256___insert(&input[1..]),
        13u8 => check_BitAlloc4K___insert(&input[1..]),
        14u8 => check_BitAlloc64K___insert(&input[1..]),
        15u8 => check_BitAlloc1M___insert(&input[1..]),
        16u8 => check_BitAlloc256___remove(&input[1..]),
        17u8 => check_BitAlloc4K___remove(&input[1..]),
        18u8 => check_BitAlloc64K___remove(&input[1..]),
        19u8 => check_BitAlloc1M___remove(&input[1..]),
        20u8 => check_BitAlloc256___any(&input[1..]),
        21u8 => check_BitAlloc4K___any(&input[1..]),
        22u8 => check_BitAlloc64K___any(&input[1..]),
        23u8 => check_BitAlloc1M___any(&input[1..]),
        24u8 => check_BitAlloc256___test(&input[1..]),
        25u8 => check_BitAlloc4K___test(&input[1..]),
        26u8 => check_BitAlloc64K___test(&input[1..]),
        27u8 => check_BitAlloc1M___test(&input[1..]),
        28u8 => check_BitAlloc256___next(&input[1..]),
        29u8 => check_BitAlloc4K___next(&input[1..]),
        30u8 => check_BitAlloc64K___next(&input[1..]),
        31u8 => check_BitAlloc1M___next(&input[1..]),
        32u8 => check_BitAlloc16___alloc(&input[1..]),
        33u8 => check_BitAlloc16___alloc_contiguous(&input[1..]),
        34u8 => check_BitAlloc16___dealloc(&input[1..]),
        35u8 => check_BitAlloc16___insert(&input[1..]),
        36u8 => check_BitAlloc16___remove(&input[1..]),
        37u8 => check_BitAlloc16___any(&input[1..]),
        38u8 => check_BitAlloc16___test(&input[1..]),
        39u8 => check_BitAlloc16___next(&input[1..]),
        _ => true,
    }
}
